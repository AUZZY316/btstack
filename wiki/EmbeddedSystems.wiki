#summary Ideas and Notes on a Port of BTstack for use on Embedded Systems.

= Introduction =
BTstack was developed and primarily used on OSs with POSIX file I/O (iOS had almost 2 million downloads recently). Smaller embedded systems luck such luxury. When running on a device without any OS some things have to adapt. Examples for such a system might be the Arduino platform, if a bigger MCU like the ATmega 2561 is used, or the [http://btnode.ethz.ch BTnode], or, your favorite ARM-developer board. :)

= Prototypes =
First run of BTstack on embedded systems without OS:
 * [http://www.youtube.com/watch?v=NlOcoKWuZhU Stellaris Cortex M3]
 * [http://www.youtube.com/watch?v=j7mJuklrIxw TI-MSP430F5438]

= Details =
The embedded port is in an early stage, but fully functional.

For use without an OS and a Bluetooth module connected via an UART, you need to implement:
 * hal_tick.h
 * hal_cpu.h
 * hal_uart_dma.h

== Run Loop ==
On embedded system without a select() function, data sources have to be polled. However, the MCU can be put into sleep mode if it will be woken by an IRQ from the UART.
Similarly, BTstack expects to get called periodically to keep it's time.


== Memory Configuration ==

BTstack has to keep track of services and active connections on the various protocol levels. In addition, the non-persistent database for remote device names and link keys needs memory. The structs for each type of data can be allocated in two different manners:
 * statically from an individual memory pools, whose maximal number of elements is defined in the config file (config.h).
 * dynamically using the malloc/free functions, if HAVE MALLOC is defined in config file.

If both HAVE MALLOC and maximal size of a pool are defined in the config file, the statical allocation will take precedence. In the case that both are omitted, an error will be raised.
To initialize the static pools you need to call btstack memory init() function.
An example of a memory configuration in config.h file for a single SPP service looks like this:

{{{
#define HCI_ACL_PAYLOAD_SIZE 52
#define MAX_SPP_CONNECTIONS 1
#define MAX_NO_HCI_CONNECTIONS MAX_SPP_CONNECTIONS
#define MAX_NO_L2CAP_SERVICES  2
#define MAX_NO_L2CAP_CHANNELS  (1+MAX_SPP_CONNECTIONS)
#define MAX_NO_RFCOMM_MULTIPLEXERS MAX_SPP_CONNECTIONS
#define MAX_NO_RFCOMM_SERVICES 1
#define MAX_NO_RFCOMM_CHANNELS MAX_SPP_CONNECTIONS
#define MAX_NO_DB_MEM_DEVICE_NAMES  0
#define MAX_NO_DB_MEM_LINK_KEYS  3
#define MAX_NO_DB_MEM_SERVICES 1
}}}

== UART Hardware Abstraction Layer  ==

On embedded systems, a Blue- tooth module can be connected via USB or an UART port. BTstack implements two UART based protocols for carrying HCI commands, events and data between a host and a Bluetooth module: HCI UART Transport Layer (H4) and H4 with eHCILL support, a lightweight low power variant by Texas Instruments.

=== IRQ & DMA UART RX ===
On embedded systems, a Bluetooth module can be connected via USB or an UART port. We will focus on UART first. 

=== HCI UART Transport Layer (H4) ===
Most embedded UART interfaces oper- ate on the byte level and generate a processor interrupt when a byte was received. In the interrupt handler, common UART drivers then place the received data in a ring buffer and set a flag for further processing or notify the higher-level code, i.e. in our case the Bluetooth stack.

Bluetooth communication is packet-based and a single packet may contain up to 1021 bytes. Calling a data received handler of the Bluetooth stack for every byte creates an unnecessary overhead. To avoid that, a Bluetooth packet can be read as multiple blocks where the amount of bytes to read is known in advance. Even better would be the use of on-chip DMA modules for these block reads, if available.

The BTstack UART HAL API reflects this design approach and the underlying UART driver has to implement the following API:

{{{
void hal ￼ uart ￼ dma ￼ init (void) ;
void hal uart dma set block received(void (∗block handler)(void));
void hal uart dma set block sent(void (∗block handler)(void));
int hal ￼ uart ￼ dma ￼ set ￼ baud ( uint32 ￼ t baud) ;
void hal uart dma send block(const uint8 t ∗buffer , uint16 t length); void hal uart dma receive block(uint8 t ∗buffer, uint16 t len);
}}}

The main HCI H4 implementations for embedded system is hci h4 transport dma. This function calls the following sequence: hal uart dma init(), hal uart dma
set block received() and hal uart dma set block sent(). After this sequence, the HCI layer will start packet processing by calling hal uart dma receive block(). The HAL implementation is responsible for reading the requested amount of bytes, stopping incoming data via the RTS line when the the requested amount of data was received and has to call the handler. By this, the HAL implementation can stay generic, while requiring only three callbacks per HCI packet.

=== H4 with eHCILL support ===

With the standard H4 protocol interface it is not possible for either the host nor the baseband controller to enter the sleep mode. Besides the official H5 protocol various chip vendors came up with proprietary solutions to this. The eHCILL support by Texas Instruments allows both the host and the baseband controller to independently enter sleep mode without loosing their synchronization with the HCI H4 Transport Layer. In addition to the IRQ- driven block-wise RX and TX, the eHCILL requires a callback for CTS interrupts.

{{{
void hal uart dma set cts irq handler(void (∗cts irq handler)(void));
void hal ￼ ￼ uart ￼ dma ￼ set ￼ sleep ( uint8 ￼ t sleep ) ;
}}}


== Arduino ==
The Arduino firmware provides interrupt-driven UART drivers with an 128 byte read buffer. It does not support CTS/RTS. Writes are blocking. A better driver is needed but possible.