#summary Ideas and Notes on a Port of BTstack for use on Embedded Systems.

= Introduction =
BTstack was developed and primarily used on OSs with POSIX file I/O (iOS had almost 2 million downloads recently). Smaller embedded systems luck such luxury. When running on a device without any OS some things have to adapt. Examples for such a system might be the Arduino platform, if a bigger MCU like the ATmega 2561 is used, or the [http://btnode.ethz.ch BTnode], or, your favorite ARM-developer board. :)

= Prototypes =
First run of BTstack on embedded systems without OS:
 * [http://www.youtube.com/watch?v=NlOcoKWuZhU Stellaris Cortex M3]
 * [http://www.youtube.com/watch?v=j7mJuklrIxw TI-MSP430F5438]

= Details =
The embedded port is in an early stage, but fully functional.

For use without an OS and a Bluetooth module connected via an UART, you need to implement:
 * hal_tick.h
 * hal_cpu.h
 * hal_uart_dma.h

== Run Loop ==
On embedded system without a select() function, data sources have to be polled. However, the MCU can be put into sleep mode if it will be woken by an IRQ from the UART.
Similarly, BTstack expects to get called periodically to keep it's time.

== HCI  Interface with IRQ & DMA ==
On embedded systems, a Bluetooth module can be connected via USB or an UART port. We will focus on UART first. 

=== IRQ & DMA UART RX===
Regular UART drivers operate on the byte level and a RX callback might be set up. As Bluetooth communication is always in a packet format, it's better to let the low-level IRQ or even DMA driver receive a block of bytes. HCI Event and ACL packets can be received as 3 block reads. This can be quite efficient for large DH5 packets of 1021 bytes.

=== UART Hardware Abstraction Layer ===

The main HCI H4 implementations for embedded system is hci_h4_transport_dma. It requires a interrupt-driven UART driver that implements the following API:

{{{
void hal_uart_dma_init(void);
void hal_uart_dma_set_block_received( void (*block_handler)(void));
void hal_uart_dma_set_block_sent( void (*block_handler)(void));
void hal_uart_dma_set_csr_irq_handler( void (*csr_irq_handler)(void));
int  hal_uart_dma_set_baud(uint32_t baud);
void hal_uart_dma_send_block(const uint8_t *buffer, uint16_t length);
void hal_uart_dma_receive_block(uint8_t *buffer, uint16_t len);
void hal_uart_dma_set_sleep(uint8_t sleep);
}}}
The semantic for this is as follows: after hal_uart_dma_init(), hal_uart_dma_set_block_received() and hal_uart_dma_set_block_sent(), the HCI layer will start packet processing by calling hal_uart_dma_receive_block(). The HAL implementation is responsible for reading the requested amount of bytes, stopping incoming data via the RTS line when the the requested amount of data was received and has to call the handler. By this, the HAL implementation can stay generic, while requiring only 3 callsbacks per HCI packet.

=== Tick Hardware Abstraction Layer ===
BTstack requires a way to learn about passing time. In an embedded configuration, the following functions have to be provided.
{{{
void hal_tick_init(void);
void hal_tick_set_handler(void (*tick_handler)(void));
int  hal_tick_get_tick_period_in_ms(void);
}}}


== Memory Configuration ==
BTstack has to keep track of services and active connections on the various protocol levels. In addition, the non-persistent database for remote device names and link keys needs memory. The structs for each type of data can be allocated in two different manners:
 * statically from an individual memory pools, whose maximal number of elements is defined in the config file (config.h).
 * dynamically using the malloc/free functions, if HAVE MALLOC is defined in config file.

If both HAVE MALLOC and maximal size of a pool are defined in the config file, the statical allocation will take precedence. In the case that both are omitted, an error will be raised.
To initialize the static pools you need to call btstack memory init() function.
An example of a memory configuration in config.h file for a single SPP service looks like this:

{{{
#define EMBEDDED

#define HAVE_TICK

// #define ENABLE_LOG_INFO 
#define ENABLE_LOG_ERROR

#define HCI_ACL_PAYLOAD_SIZE 52

// 
#define MAX_SPP_CONNECTIONS 1

#define MAX_NO_HCI_CONNECTIONS MAX_SPP_CONNECTIONS
#define MAX_NO_L2CAP_SERVICES  2
#define MAX_NO_L2CAP_CHANNELS  (1+MAX_SPP_CONNECTIONS)
#define MAX_NO_RFCOMM_MULTIPLEXERS MAX_SPP_CONNECTIONS
#define MAX_NO_RFCOMM_SERVICES 1
#define MAX_NO_RFCOMM_CHANNELS MAX_SPP_CONNECTIONS
#define MAX_NO_DB_MEM_DEVICE_NAMES  0
#define MAX_NO_DB_MEM_LINK_KEYS  3
#define MAX_NO_DB_MEM_SERVICES 1
}}}

== Arduino ==
The Arduino firmware provides interrupt-driven UART drivers with an 128 byte read buffer. It does not support CTS/RTS. Writes are blocking. A better driver is needed but possible.