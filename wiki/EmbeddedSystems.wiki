#summary Ideas and Notes on a Port of BTstack for use on Embedded Systems.

= Introduction =
BTstack was developed and primarily used on OSs with POSIX file I/O (iOS had almost 2 million downloads recently). Smaller embedded systems luck such luxury. When running on a device without any OS some things have to adapt. Examples for such a system might be the Arduino platform, if a bigger MCU like the ATmega 2561 is used, or the [http://btnode.ethz.ch BTnode], or, your favorite ARM-developer board. :)

= Prototypes =
First run of BTstack on embedded systems without OS:
 * [http://www.youtube.com/watch?v=NlOcoKWuZhU Stellaris Cortex M3]
 * [http://www.youtube.com/watch?v=j7mJuklrIxw TI-MSP430F5438]

= Details =
The embedded port is in an early stage, but usable. New files for embedded:
 * run_loop_embedded.c
 * hci_transport_h4_dma.c

Although intended for use on embedded systems, the use of POSIX semantics during early development led to unnecessary dependencies which should be cleaned beforehand.

== Run Loop ==
On embedded system without a select() function, data sources have to be polled.
Similarly, it is common to have an timer IRQ handler that is executed periodically.

== HCI  Interface with IRQ & DMA ==
On embedded systems, a Bluetooth module can be connected via USB or an UART port. We will focus on UART first. 

=== Blocking Write ===
Write: The current implementation uses a blocking write to send data to the BT module with the hidden knowledge that the OS will buffer incoming data. Instead, a polled "data source" can be used to transfer data from an output buffer to the Bluetooth module, if the assumption of the synchronous write is removed and higher layers are made responsible for not sending a second packet while the previous is not acknowledged.

=== IRQ & DMA UART RX===
I've created a first IRQ driver for the MSP430 that is aware of the HCI packet format and only signals the run loop when a complete HCI packet was received. RTS is used to request a stop of incoming data after a complete packet was received. This is quite efficient, however I don't see how this can be made more portable.

Regular UART drivers operate on the byte level and a RX callback might be set up. As Bluetooth communication is always in a packet format, it's better to let the low-level IRQ or even DMA driver receive a block of bytes. HCI Event and ACL packets can be received as 3 block reads. This can be quite efficient for large DH5 packets of 1021 bytes.

=== UART Hardware Abstraction Layer ===
The main HCI H4 implementations for embedded system will be hci_h4_dma. hci_h4_dma roughly has to provide
{{{
void hal_uart_dma_init(void);
void hal_uart_dma_set_block_received( void (*block_handler)(void));
int  hal_uart_dma_set_baud(uint32_t baud);
void hal_uart_dma_send_block(uint8_t *buffer, uint16_t length);
void hal_uart_dma_receive_block(uint8_t *buffer, uint16_t len);
}}}
The semantic for this is as follows: after hal_bt_init() and hal_bt_set_block_receive(), the HCI layer will start packet processing by calling hal_bt_read_block(). The HAL implementation is responsible for reading the requested amount of bytes, stopping incoming data via the RTS line when the the requested amount of data was received and has to call the handler. By this, the HAL implementation can stay generic, while requiring only 3 callsbacks per HCI packet.

=== Tick Hardware Abstraction Layer ===
BTstack requires a way to learn about passing time. In an embedded configuration, the following functions have to be provided.
{{{
void hal_tick_init(void);
void hal_tick_set_handler(void (*tick_handler)(void));
int  hal_tick_get_tick_period_in_ms(void);
}}}

== Arduino ==
The Arduino firmware provides interrupt-driven UART drivers with an 128 byte read buffer. It does not support CTS/RTS. Writes are blocking.

With the blocking write (same on POSIX), it is necessary that incoming data is stopped using the hardware handshake. This could be done as part of the blocking write or as an extension of the UART driver. Support for RTS/CTS seems like the better option.

== Next steps ==
 * make sure that app/stack only sends one command/acl packet at a time, to allow for non-blocking writes done by a IRQ UART driver