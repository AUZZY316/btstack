#summary Describes the overall architecture and how clients interact with the stack.

= Introduction =

The *BT Stack* has to support multiple clients. This is because the *Host Controller Interface* supported by all Bluetooth devices assumes that a single Bluetooth Stack is in control. 

== Bluetooth Daemon ==
A minimal *BT daemon* is necessary to handle the multiplexing of multiple applications. Applications shall communicate with the BT daemon over Unix sockets. If possible, we want to save resources by running the daemon in a single thread. An introduction on single thread unix socket servers: http://www.lowtek.com/sockets/select.html

== Current architecture ==
Application -> BT library (RFCOMM/L2CAP/SDP) -> Unix Socket -> BT daemon (RFCOMM/L2CAP/SDP) -> HCI transport support (H4, H5, USB) -> Bluetooth module

== Development/Debugging ==
*BT daemon* will be able to write HCI dumps in the bluez-hcidump format which can be read by the hcidump tool, the GNOME Bluetooth-Analyzer, and Wireshark. Wireshark is available on all platforms. Optionally, Apple's Packet Logger format can be supported for easier debugging on OS X.

libUSB allows to use USB BT modules during development. The newer libusb-1.0 supports asynchronous operations by way of exposing an internal file descriptor. This fits the single thread unix socket server.
 
However, it is not ported to Mac or Windows yet. As USB on non-linux systems will be only relevant for debugging, a separate thread can use the older libUSB-1.0 and signal the main loop when data is ready from USB.

== Design decisions ==
How much state is kept in HCI daemon, how much in the Bluetooth library? A minimal BT daemon needs to keep state that is shared between all clients. It also has to manage the single Bluetooth resource, e.g., Bluetooth should stay on as long as at least on client is connected.

== Shared state in BT daemon ==
  * List of Baseband connections, their state sniffing/hold/park..
  * Bluetooth state: off/initializing/on/terminating
  * Configuration: page scan timeout, discoverable, etc..
  * List of L2CAP channels in listening mode (a.k.a server)
  * List of active L2CAP channels

== HCI Transport API ==
The HCI Transport API allows the HCI daemon to use different transport implementations.
 
{{{
typedef struct {
    int    (*open)(void *transport_config);
    int    (*close)();
    int    (*send_cmd_packet)(void *packet, int size);
    int    (*send_acl_packet)(void *packet, int size);
    void   (*register_event_packet_handler)(void (*handler)(void *packet, int size));
    void   (*register_acl_packet_handler)  (void (*handler)(void *packet, int size));
    int    (*get_fd)();      // <-- only used for select(..) call
    int    (*handle_data)(); // <-- to be called when select( .. ) returns for the fd
    const char * (*get_transport_name)();
} hci_transport_t;
}}}

Note: packet sizes are not needed for HCI packets (ACL, Command, Event) as they contain length information. Could remove those from the function paramters.

== BT Control API ==
In addition to the pure BT stack implementation, there is a need for functions such as turning on/off the Bluetooth module, configuring a particular transport protocol including the physical connection (H4/H5/USB, device path, baud rate, flow control, Vendor ID, Product ID). This will be device specific, e.g., turning on Bluetooth on the iPhone requires to make use of Apple's BlueTool, on the BTnode, the power is controlled by a special kernel function.

== Timer ==
There are two options for timer support in a single-threaded daemon. The first is using an explicit list of timeouts together with context information, the second detects timeouts on the fly and can determine the time until the next check.
  # If timeouts are kept in an ordered list, the HCI daemon can use the time until the next timeout as timeout in the select() call and process them. A linked list will be fine with an absolute time, a callback and an optional arg. As the HCI daemon will run in a single thread, removing timer events will be free of race conditions. This approach is compatible to the NSRunLoop used on the iPhone.
  # By examining all baseband links and L2CAP connections, all potential timeouts can be identified and/or the time of the next timeout be calculated. On the positive side, when examining the current state, all context information for a reaction to the timeout is directly available. With the timer list approach, this information would have to be extracted and stored as part of the timer nodes.

== Opaque BT Connection Handles ==
The BT module might immediately reuse a baseband connection handle after it is closed. In BTnut, we mapped the handle ids generated by the BT module to a 16 bit application connection handle. By this, use of obsolete baseband handles by the application could be detected and ignored.

== HCI Command Flow Control ==
Each command complete and command status event returns the amount of HCI commands the host is allowed to send to the BT module. A simple approach to this is to not generate command packets while, we cannot send them. This can be achieved by not reading from the clients and by only updating the internal state based on HCI events until packets are ready. (See the unfortunate code in BTnut bt_hci.c - scary!)

== ACL Flow Control ==
Similar to the HCI Command Flow Control, the flow of ACL packets has to be controlled, e.g. not to overrun the BT module. On the BTnode, it was the other way round. In any case, the data coming from a unix socket can just be delayed. For L2CAP packets that are larger than the maximal ACL packet, the flow control and the segmentation is better implemented on the BT daemon instead of the client. Otherwise, if multiple clients send in parallel, data for the same baseband link might be interleaved, which is not possible. Similar, for each link with open L2CAP connections, 2 L2CAP buffers of maximal (of all L2CAP connections) are needed for a) completely assemble an incoming L2CAP packet, b) allow the reception of a complete L2CAP packet from the clients without blocking.

== Incoming Connection Requests ==
As L2CAP and higher protocols are the focus of this stack, we assume that baseband connections are only a means for the higher level protocols. Therefore, we accept all baseband connections similar to the BT stack on the Mac, but we disconnect baseband connections when there is no higher-layer service established within half a minute. An incoming connection is therefore expected to open a higher-layer connection through L2CAP immediately.

== Baseband Connection Management ==
The HCI daemon should know which connections are open. A linked list will be fine. Necessary functions: look up by BD_ADDR, module connection handle and application connection handle. Most changes are updated by processing events (Connection Complete, Connection Request, Disconnection Complete, Authentication Complete, Role Change, Number of Completet Packets, Connection Packet Type Changed) 

== Modular Design ==
The HCI daemon is started with a pointer to an hci_transport_t structure, a pointer to an hci transport configuration structure and a pointer to an bt_control_t structure.

== L2CAP State Machine ==
Most part of the L2CAP State Machine will be implemented as part of the BT daemon. However, on the client side, a subset of state information is required, too.

== References ==
  * Official Bluetooth specification: It used to be available from Bluetooth.org, but I heard you cannot get them for free anymore.
  * CSR provides a wealth of documents on HCI and their hardware after registering a free account at http://www.csrsupport.com
  * Nice [http://www.inf.ethz.ch/personal/kasten/research/bathtub/bluetooth/ L2CAP Summary]
  * BlueZ - The GPL Linux Bluetooth Stack: http://www.bluez.org/
    * The implementation for CSR lists some of the magical properties set by the Apple BlueTool init scripts, I could not find in the CSR documentation.
  * The lightweight Bluetooth Stack (lwBT). Another embedded BT stack, intended for use with the lightweight IP stack (lwIP): http://www.sm.luth.se/~conny/lwbt/
  * The ETH BTnut BT Stack: http://www.btnode.ethz.ch
    * Documentation on the HCI implementation: http://www.btnode.ethz.ch/static_docs/btnut/bt-stack.pdf
    * HCI API: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__api_8h.html
    * HCI Commands: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__cmds_8h.html/group__btnode__resources.html#btnode_bt-stack
  * libUSB: http://libusb.wiki.sourceforge.net/