#summary Describes the overall architecture and how clients interact with the stack.

= Introduction =

The *BT Stack* has to support multiple clients. This is because the *Host Controller Interface* supported by all Bluetooth devices assumes that a single Bluetooth Stack is in control. 

== HCI Daemon ==
A minimal *HCI daemon* is necessary to handle the multiplexing of multiple applications. Applications shall communicate with the HCI daemon over Unix sockets. If possible, we want to save resources by running the HCI daemon in a single thread. An introduction on single thread unix socket servers: http://www.lowtek.com/sockets/select.html

== Current architecture ==
Application -> BT library -> Unix Socket -> HCI daemon -> HCI transport support (H4, H5, USB) -> Bluetooth module.

== Development/Debugging ==
*HCI daemon* will be able to write hci dumps in the bluez-hcidump format which can be read by the hcidump tool, the GNOME Bluetooth-Analyzer, and Wireshark. Wireshark is available on all platforms. Optionally, Apple's Packet Logger format can be supported for easier debugging on OS X.

libUSB allows to use USB BT modules during development. The newer libusb-1.0 supports asynchronous operations by way of exposing an internal file descriptor. This fits the single thread unix socket server.
 
However, it is not ported to Mac or Windows yet. As USB on non-linux systems will be only relevant for debugging, a separate thread can use the older libUSB-1.0 and signal the main loop when data is ready from USB.

== Future design decisions ==
How much state is kept in HCI daemon, how much in the Bluetooth library? A minimal HCI daemon needs to keep state that is shared between all clients. It also has to manage the single Bluetooth resource, e.g., Bluetooth should stay on as long as at least on client is connected.

== Shared state in HCI daemon ==
  * List of Baseband connections, their state sniffing/hold/park..
  * Bluetooth state: off/initializing/on/terminating
  * Configuration: page scan timeout, discoverable, etc..

== HCI Transport API ==
The HCI Transport API allows the HCI daemon to use different transport implementations.
 
{{{
typedef struct {
    int    (*open)(void *transport_config);
    int    (*close)();
    int    (*send_cmd_packet)(void *packet, int size);
    int    (*send_acl_packet)(void *packet, int size);
    void   (*register_event_packet_handler)(void (*handler)(void *packet, int size));
    void   (*register_acl_packet_handler)  (void (*handler)(void *packet, int size));
    int    (*get_fd)();      // <-- only used for select(..) call
    int    (*handle_data)(); // -- to be called when select( .. ) returns for the fd
    const char * (*get_transport_name)();
} hci_transport_t;
}}}

== BT Control API ==
In addition to the pure HCI implementation, there is a need for functions such as turning on/off the Bluetooth module, configuring a particular transport protocol including the physical connection (H4/H5/USB, device path, baud rate, flow control, Vendor ID, Product ID). This will be device specific, e.g., turning on Bluetooth on the iPhone requires to make use of Apple's BlueTool, on the BTnode, the power is controlled by a special kernel function.

== Timer ==
If timeouts are kept in an ordered list, the HCI daemon can use the time until the next timeout as timeout in the select() call and process them. A linked list will be fine with an absolute time, a callback and an optional arg. As the HCI daemon will run in a single thread, removing timer events will be free of race conditions. This approach is compatible to the NSRunLoop used on the iPhone.

== Opaque BT Connection Handles ==
The BT module might immediately reuse a baseband connection handle after it is closed. In BTnut, we mapped the handle ids generated by the BT module to a 16 bit application connection handle. By this, use of obsolete baseband handles by the application could be detected and ignored.

== HCI Command Flow Control ==
Each command complete and command status event returns the amount of HCI packets the host is allowed to send to the BT module. How to assert that no HCI command is sent while Num_HCI_Command_Packets is zero? If HCI are only received via an unix socket, the incoming command can easily be delayed. If the HCI daemon has to sent commands on its own, the command has to be parked somehow until they can be sent. See the unfortunate code in BTnut bt_hci.c

== HCI ACL Flow Control ==
Similar to the HCI Command Flow Control, the flow of ACL packets has to be controlled, e.g. not to overrun the BT module. On the BTnode, it was the other way round. In any case, the data coming from a unix socket can just be delayed.

== Incoming Connection Requests ==
What should the HCI daemon do when a connection is opened from an outside device? Apple BT stack on the Mac accepts all connections but disconnects them when there is no higher-layer service established within half a minute. An incoming connection is therefore expected to open a higher-layer connection through L2CAP.

== Baseband Connection Management ==
The HCI daemon should know which connections are open. A linked list will be fine. Necessary functions: look up by BD_ADDR, module connection handle and application connection handle. Most changes are updated by processing events (Connection Complete, Connection Request, Disconnection Complete, Authentication Complete, Role Change, Number of Completet Packets, Connection Packet Type Changed) 

== Modular Design ==
The HCI daemon is started with a pointer to an hci_transport_t structure, a pointer to an hci transport configuration structure and a pointer to an bt_control_t structure.

== L2CAP State Machine ==
L2CAP could be implemented in the client library or as part of the HCI daemon. An implementation on the client side facilitates flow control and management of connections. Also the HCI daemon can be small and efficient. Is the memory for the code of shared libraries only used once ? (The memory for actual connections is fine). How could this adapt to a small embedded system? How is the dispaching done?

== References ==
  * Official Bluetooth specification: It used to be available from Bluetooth.org, but I heard you cannot get them for free anymore.
  * CSR provides a wealth of documents on HCI and their hardware after registering a free account at http://www.csrsupport.com
  * BlueZ - The GPL Linux Bluetooth Stack: http://www.bluez.org/
    * The implementation for CSR lists some of the magical properties set by the Apple BlueTool init scripts, I could not find in the CSR documentation.
  * The lightweight Bluetooth Stack (lwBT). Another embedded BT stack, intended for use with the lightweight IP stack (lwIP): http://www.sm.luth.se/~conny/lwbt/
  * The ETH BTnut BT Stack: http://www.btnode.ethz.ch
    * Documentation on the HCI implementation: http://www.btnode.ethz.ch/static_docs/btnut/bt-stack.pdf
    * HCI API: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__api_8h.html
    * HCI Commands: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__cmds_8h.html/group__btnode__resources.html#btnode_bt-stack
  * libUSB: http://libusb.wiki.sourceforge.net/