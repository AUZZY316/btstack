#summary Describes the overall architecture and how clients interact with the stack.

= Introduction =

The *BT Stack* has to support multiple clients. The *Host Controller Interface* supported by all Bluetooth devices assumes that a single Bluetooth Stack is in control. 

A minimal *HCI daemon* is necessary to handle the multiplexing of multiple applications. Applications shall communicate with the HCI daemon over Unix sockets. If possible, we want to save resources by running the HCI daemon in a single thread.

Current architecture:
Application -> BT library -> Unix Socket -> HCI daemon -> HCI transport support (H4, H5, USB) -> Bluetooth module.


Development/Debugging: libUSB allows to use USB BT modules during development.

Intro/Overview for single thread unix socket server: http://www.lowtek.com/sockets/select.html

Design decision: how much state is kept in HCI daemon, how much in the Bluetooth library? A minimal HCI daemon needs to keep state that is shared between all clients. It also has to manage the single Bluetooth resource, e.g., Bluetooth should stay on as long as at least on client is connected.


Shared state:
 * List of Baseband connections
 * Bluetooth state: off/initializing/on/terminating
 * Configuration: page scan timeout, discoverable, etc..

BT HCI Transport API:
 * send_hci_packet()
 * register_hci_packet_receive_callback( .. )

BT Control API: In addition to the pure HCI implementation, there is a need for functions such as turning on/off the Bluetooth module, configuring a particular transport protocol including the physical connection (H4/H5/USB, device path, baud rate, flow control, Vendor ID, Product ID). This will be device specific, e.g., turning on Bluetooth on the iPhone requires to make use of Apple's BlueTool, on the BTnode, the power is controlled by a special kernel funtion.
 