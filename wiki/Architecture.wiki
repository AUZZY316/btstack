#summary Describes the overall architecture and how clients interact with the stack.

= Introduction =

*BTstack* is a Bluetooth stack that is mainly designed for embedded devices where resources are scarce. Despite scarce resources, it allows multiple applications to make use of Bluetooth services at the same time. The BTstack architecture consists of a Bluetooth server, called *BTdaemon*, which handles client requests, and a corresponding client library, which forwards the requests to the BTdaemon. In the following, the design of the BTdaemon is explained in more detail.


= BTdaemon Architecture =


The *BTdaemon* is necessary to handle multiple clients. Clients use the BTstack client library to communicate with the BTdaemon over TCP or Unix sockets. 
In addition to necessary *socket server*, the other main components of the BTdaemon are: a *run loop* and the actual *Bluetooth stack*. The Bluetooth stack and the socket server are implemented as a collection of finite state machines. The state machines are executed by a single run loop, where all sockets and the Bluetooth module are registered as individual data sources. This design allows for a single-threaded implementation, which avoids concurrency problems and facilitates porting and running BTstack on embedded systems. As embedded systems usually implement a single functionality, support for multiple clients results in an unnecessary overhead. In this case, e.g., to support 8-bit microcontrollers, the socket server can be omitted and the client directly integrated into the BTdaemon run loop.

http://btstack.googlecode.com/svn/files/BTstack_architecture.png
BTstack architecture 

== Posix Run Loop Implementation ==

In the widely spread Posix standard, everything (files, I/Os, sockets, devices) is accessed via file descriptors. The BTdaemon's run loop is exploiting this fact to manage multiple data sources without multithreading. Such a data source is defined by a file descriptor and an associated data_source_ready handler: 

{{{
typedef struct data_source {
    linked_item_t item;                                 // <-- used internally by RunLoop
    int  fd;                                            // <-- file descriptors to watch or 0
    int  (*data_source_ready)(struct data_source *ds);  // <-- handler
} data_source_t;
}}}


All data sources are tracked in parallel using the [http://www.manpagez.com/man/2/select/ select()] call. For a detailed introduction into handling of multiple file descriptors within a single thread, check this [http://www.lowtek.com/sockets/select.html single-threaded socket server].

Besides data sources, the BTdaemon needs to track various Bluetooth-related timeout conditions. If timeouts are kept in an ordered list, the time of the next timeout can be accessed in constant time. The run loop uses the interval until the next timeout in the select() call. After select() returns, the run loop checks which timeouts are ready and calls their corresponding handler.

The descriped run loop approach is compatible with many GUI frameworks, notably Cocoa on Mac OS X and CocoaTouch on the iPhone. This allows to directly integrate the BTstack client library also into GUI applications.

=== Flow Control for Socket Server ===

As the socket servers can receive messages from the clients at any time, a command or an ACL packet might be sent while we cannot directly pass it on to the Bluetooth module. In this case, we have to _block_ this socket until the packet can be sent. If the socket server would skip reading data, it would be called again immediately, as the incoming socket is still ready. The data_source of the socket has to be excluded from the run loop, which can be achieved by removing the data_source from the run loop. In any case, to be activated again, the socket server has to be notified when new event packets are received. If a new event is received, the socket server can check again, if it can pass the incoming data packet on to the Bluetooth module.

=== HCI Command Flow Control ===
Each command complete and command status event returns the amount of HCI commands the host is allowed to send to the BT module. A simple approach to this is to not generate command packets while, we cannot send them. This can be achieved by not reading from the clients and by only updating the internal state based on HCI events until packets are ready. (See the unfortunate code in BTnut bt_hci.c - scary!)

== Shared state ==
  * List of Baseband connections, their state sniffing/hold/park..
  * Bluetooth state: off/initializing/on/terminating
  * Configuration: page scan timeout, discoverable, etc..
  * List of L2CAP channels in listening mode (a.k.a server)
  * List of active L2CAP channels


=== Baseband Connection Management ===
The HCI daemon should know which connections are open. A linked list will be fine. Necessary functions: look up by BD_ADDR, module connection handle and application connection handle. Most changes are updated by processing events (Connection Complete, Connection Request, Disconnection Complete, Authentication Complete, Role Change, Number of Completet Packets, Connection Packet Type Changed) 


== Modular Design ==
The HCI daemon is started with a pointer to an hci_transport_t structure, a pointer to an hci transport configuration structure and a pointer to an bt_control_t structure.

=== HCI Transport API ===
The HCI Transport API allows the HCI daemon to use different transport implementations. The hci_tranport_t control structure contains a data_source_t structure used for the single-thread implementation.
 
{{{
typedef struct {
    int    (*open)(void *transport_config);
    int    (*close)();
    int    (*send_cmd_packet)(uint8_t *packet, int size);
    int    (*send_acl_packet)(uint8_t *packet, int size);
    void   (*register_event_packet_handler)(void (*handler)(uint8_t *packet, int size));
    void   (*register_acl_packet_handler)  (void (*handler)(uint8_t *packet, int size));
    const char * (*get_transport_name)();
} hci_transport_t;
}}}

Note: packet sizes are not needed for HCI packets (ACL, Command, Event) as they contain length information. Could remove these from the function parameters.

=== BT Control API ===
In addition to the pure BT stack implementation, there is a need for functions such as turning on/off the Bluetooth module, configuring a particular transport protocol including the physical connection (H4/H5/USB, device path, baud rate, flow control, Vendor ID, Product ID). This will be device specific, e.g., turning on Bluetooth on the iPhone requires to make use of Apple's BlueTool, on the BTnode, the power is controlled by a special kernel function.


== Goodies ==

=== HCI Logging ===
*BTdaemon* is able to write HCI dumps in several formats. In supports both the bluez-hcidump format which can be read by the hcidump tool, the GNOME Bluetooth-Analyzer, and Wireshark, and in Apple's PacketLogger format for easier debugging on OS X. Also, it can just dump HCI packets to stdout.

=== Development/Debugging ===
In addition to support for Bluetooth modules connected by a serial connection (H4/H5), libUSB allows to use USB BT modules during development. More on the [HCI_USB_Transport HCI USB Transport page]. 

== Unsorted ==


=== Opaque BT Connection Handles ===
The Bluetooth module might immediately reuse a baseband connection handle after it is closed. In BTnut, we mapped the handle ids generated by the BT module to a 16 bit application connection handle. By this, use of obsolete baseband handles by the application could be detected and ignored.


== References ==
  * Official Bluetooth specification: http://www.bluetooth.com/Bluetooth/Technology/Building/Specifications/Default.htm
  * CSR provides a wealth of documents on HCI and their hardware after registering a free account at http://www.csrsupport.com
  * BlueZ - The GPL Linux Bluetooth Stack: http://www.bluez.org/
    * The implementation for CSR lists some of the magical properties set by the Apple BlueTool init scripts, I could not find in the CSR documentation.
  * The lightweight Bluetooth Stack (lwBT). Another embedded BT stack, intended for use with the lightweight IP stack (lwIP): http://www.sm.luth.se/~conny/lwbt/
  * The ETH BTnut BT Stack: http://www.btnode.ethz.ch
    * Documentation on the HCI implementation: http://www.btnode.ethz.ch/static_docs/btnut/bt-stack.pdf
    * HCI API: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__api_8h.html
    * HCI Commands: http://www.btnode.ethz.ch/static_docs/doxygen/btnut/bt__hci__cmds_8h.html/group__btnode__resources.html#btnode_bt-stack
  * libUSB: http://libusb.wiki.sourceforge.net/