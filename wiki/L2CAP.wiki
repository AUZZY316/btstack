#summary This page describes the L2CAP Implementation for BTstack.

= Introduction =

L2CAP is primarily concerned with:
  # Protocol multiplexing
  # Segmentation and reassembly operations

We do not intend to support per-channel flow control or retransmissions. Therefore we will only implement L2CAP Basic Mode. The L2CAP State machine will follow the overall goal of non-blocking operations.

== Client API ==
All L2CAP commands are forwarded to the BTdaemon with the bt_send_cmd. Maybe explicit function calls will be provided at a later time - using a code generator. 

=== Outgoing Connections ===
To open an L2CAP connection use the l2cap_create_channel command:
{{{
  // create channel
  l2cap_create_channel( bd_addr, PSM);

  // transfer
  l2cap_send(uint16_t source_cid, uint8_t *data, uint16_t len);
}}}

On success, an HCI_EVENT_L2CAP_CHANNEL_OPENED event will generated which contains the source_cid. Data received on the channel will be received by the data callback. To send data over the channel, use the l2cap_send function.

=== Incoming Connections ===
Incoming Connections are not implemented yet. They will be implemented like this: To register an L2CAP PSM, send the l2cap_register_psm(..) command. On incoming L2CAP connection request, an event will be received by the application event handler. The application is then free to accept or decline the request using the l2cap_decline/accept_connection commands. 

{{{
  l2cap_register_psm(uint16_t psm, uint16_t incoming_mtu);
  l2cap_accept_connection(bd_addr_t  remote_address, uint16_t dest_cid);
  l2cap_decline_connection(bd_addr_t remote address, utin16_t dest_cid, uint8_t reason);
  l2cap_unregister_psm(uint16_t psm);

}}}

= Details =

== L2CAP State Machine ==
Most part of the L2CAP State Machines will be implemented as part of the BTdaemon. For each connection (channel), a separate state machine is required. On the client side, a subset of state information is required, too.

=== Dispatching L2CAP Signaling Commands to Channels State Machines ===
To process incoming L2CAP Signaling Commands, they need to be dispatched to the responsible Channel state machine. The following lists the different commands and how they are dispatched:
  # command reject: id
  # connection request: PSM - not a particular channel
  # connection response: id
  # configuration request: dest_cid == src_cid
  # configuration response: id
  # disconnect request: dest_cid == src_cid
  # disconnection response: id
  # echo request: Stack        - not a particular channel
  # echo response: id          - not a particular channel
  # information request: Stack - not a particular channel
  # information response: id   - not a particular channel

Commands 0x08-0x0b are not channel related, also 0x02 is used to setup a new channel. We only have to react to {0x01-0x07}\{0x02}. For command codes with odd number, we match by the signal identifier sent earlier by the channel - the channel_t struct stores the last sent signal identifier. Otherwise, we match by the destination channel ID.

=== l2cap_listener_t (a.k.a Socket) ===
  * PSM
  * MTU
  * Connection Indication Callback

=== l2cap_channel_t ===
{{{
typedef struct {

    linked_item_t item;

    L2CAP_STATE state;
    bd_addr_t address;
    hci_con_handle_t handle;
    uint16_t  psm;
    uint8_t   sig_id;  // last sent
    uint16_t  local_cid;
    uint16_t  dest_cid;
    // uint16_t mtu_incoming;
    // uint16_t mtu_outgoing;
    // uint16_t flush_timeout_incoming;
    // uint16_t flush_timeout_outgoing;
} l2cap_channel_t;
}}}
 
== ACL Flow Control ==
Similar to the HCI Command Flow Control, the flow of ACL packets has to be controlled, e.g. not to overrun the BT module. On the BTnode, it was the other way round. In any case, the data coming from a unix socket can just be delayed. For L2CAP packets that are larger than the maximal ACL packet, the flow control and the segmentation is better implemented on the BT daemon instead of the client. Otherwise, if multiple clients send in parallel, data for the same baseband link might be interleaved, which is not possible. 

== ACL Buffers at BT Daemon ==
  * For each baseband connection:
    * 2 ACL buffers for incoming DH5 packets
    * 2 L2CAP packet buffers of size max MTU(x) (x is set of all L2CAP connections on this baseband connection). One L2CAP buffer is needed for assmbly of incoming ACL packets, the second for receiving client complete client packets


== References ==
  * Official Bluetooth specification, see [Architecture]
  * Nice [http://www.inf.ethz.ch/personal/kasten/research/bathtub/bluetooth/ L2CAP Summary]
  * The lightweight Bluetooth Stack (lwBT). Another embedded BT stack, intended for use with the lightweight IP stack (lwIP): http://www.sm.luth.se/~conny/lwbt/
  * The ETH BTnut BT Stack: http://www.btnode.ethz.ch