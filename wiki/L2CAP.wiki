#summary This page describes the L2CAP Implementation for BTstack.

= Introduction =

L2CAP is primarily concerned with:
  # Protocol multiplexing
  # Segmentation and reassembly operations

We do not intend to support per-channel flow control or retransmissions. Therefore we will only implement L2CAP Basic Mode. The L2CAP State machine will follow the overall goal of non-blocking operations.

== Client API ==
All L2CAP commands are forwarded to the BTdaemon with the bt_send_cmd. Maybe explicit function calls will be provided at a later time - using a code generator. 

=== Outgoing Connections ===
To open an L2CAP connection use the l2cap_create_channel command:
{{{
  // create channel
  bt_send_cmd(&l2cap_create_channel, bd_addr, uint16 psm);

  // transfer
  l2cap_send(uint16_t source_cid, uint8_t *data, uint16_t len);
}}}

On success, an HCI_EVENT_L2CAP_CHANNEL_OPENED event will generated which contains the source_cid. Data received on the channel will be received by the data callback. To send data over the channel, use the l2cap_send function.

=== Incoming Connections ===
To register an L2CAP service, send the l2cap_register_service(uint16_t psm, uint16_t mtu) command. The incoming MTU is ignored for not. On incoming L2CAP connection request, an L2CAP_EVENT_INCOMING_CONNECTION event will be received by the application event handler. The application is then free to accept or decline the request using the l2cap_decline/accept_connection commands. 

{{{
  bt_send_cmd(&l2cap_register_psm, uint16_t psm, uint16_t incoming_mtu);
  bt_send_cmd(&l2cap_unregister_psm, uint16_t psm);

  bt_send_cmd(&l2cap_accept_connection, uint16_t source_cid);
  bt_send_cmd(&l2cap_decline_connection, utin16_t source_cid, uint8_t reason);
}}}

= Details =

== L2CAP State Machine ==
Most part of the L2CAP State Machines will be implemented as part of the BTdaemon. For each connection (channel), a separate state machine is required. On the client side, a subset of state information is required, too.

=== Dispatching L2CAP Signaling Commands to Channels State Machines ===
To process incoming L2CAP Signaling Commands, they need to be dispatched to the responsible Channel state machine. The following lists the different commands and how they are dispatched:
  # command reject: id
  # connection request: PSM - not a particular channel
  # connection response: id
  # configuration request: dest_cid == src_cid
  # configuration response: id
  # disconnect request: dest_cid == src_cid
  # disconnection response: id
  # echo request: Stack        - not a particular channel
  # echo response: id          - not a particular channel
  # information request: Stack - not a particular channel
  # information response: id   - not a particular channel

Commands 0x08-0x0b are not channel related, also 0x02 is used to setup a new channel. We only have to react to {0x01-0x07}\{0x02}. For command codes with odd number, we match by the signal identifier sent earlier by the channel - the channel_t struct stores the last sent signal identifier. Otherwise, we match by the destination channel ID.

=== l2cap_listener_t ===
{{{
typedef struct {
    // linked list - assert: first field
    linked_item_t    item;

    // service id
    uint16_t  psm;
    
    // incoming MTU
    uint16_t mtu;
    
    // provider for this server
    connection_t *connection;    
} l2cap_service_t;
}}}

=== l2cap_channel_t ===
{{{
typedef struct {

    linked_item_t item;

    L2CAP_STATE state;
    bd_addr_t address;
    hci_con_handle_t handle;
    uint16_t  psm;
    uint8_t   sig_id;  // last sent
    uint16_t  local_cid;
    uint16_t  dest_cid;
    // uint16_t mtu_incoming;
    // uint16_t mtu_outgoing;
    // uint16_t flush_timeout_incoming;
    // uint16_t flush_timeout_outgoing;
} l2cap_channel_t;
}}}
 
== ACL Flow Control ==
Similar to the HCI Command Flow Control, the flow of ACL packets has to be controlled, e.g. not to overrun the BT module. On the BTnode, it was the other way round. In any case, the data coming from a unix socket can just be delayed. For L2CAP packets that are larger than the maximal ACL packet, the flow control and the segmentation is better implemented in the BTdaemon than in the client. Otherwise, if multiple clients send in parallel, data for the same baseband link might be interleaved, which is not possible. 

== ACL Buffers at BT Daemon ==
  * For each baseband connection:
    * 2 ACL buffers for incoming packets. 1 x client, 1 x Bluetooth chipset.
    * 2 L2CAP packet buffers of size max MTU(X) (X is set of all L2CAP connections on this baseband connection). One L2CAP buffer is needed for assembly of received ACL packets, the second for receiving complete client packets.


== References ==
  * Official Bluetooth specification and other open stacks, see [Architecture]
  * Nice [http://www.inf.ethz.ch/personal/kasten/research/bathtub/bluetooth/ L2CAP Summary]